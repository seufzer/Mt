<html>

<head lang="de">
	<meta charset="utf-8">
	<title></title>
	<link rel="stylesheet" type="text/css" href="format.css">
	<style type="text/css">
		<!-- a:link {
			font-family: Arial;
			font-size: 10pt;
			text-decoration: none;
		}

		a:visited {
			font-family: Arial;
			font-size: 10pt;
			text-decoration: none;
		}

		a:hover {
			color: #FF3333;
			text-decoration: none;
			font-weight: normal;
			font-size: 10pt;
		} //-->

	</style>
</head>

<body>

	<iframe src="oben.html" width="800" height="120" name="IFrame3" id="IFrame3" scrolling="no" frameborder="0">
         <p>Ihr Browser kann leider keine eingebe5tteten Frames anzeigen:Sie k&ouml;nnen die eingebettete Seite &uuml;ber den
         folgenden.</p>
	</iframe>
	<br>
	<h3>Ü4: Manipulation von Bildparametern, Farbsysteme</h3>
	<div>
		<h3>1. Aufgabe RGB und YCbCr</h3>
		
		<p class="task"><b>a.</b>RGB ist der gebräuchlichste Farbraum bei der Aufzeichnung und Darstellung von Bildern. Hier wird das Lichtspektrum in seine Rot-, Grün- und Blauanteile aufgespalten. Der YCbCr Farbraum hingegen besteht aus der Luminanz Y (Helligkeit) und den Farbanteilen (Chrominanz) Cb und Cr. Die RGB Farben eines Bildes lassen sich also in den YCbCr Farbraum transformieren. Für viele Anwendungen, z.B. die Bildkompression, ist es günstig, Helligkeits- und Farbinformation getrennt zu verarbeiten. Nenne den physiologischen Grund dafür!</p>

		
		<p class="task"><b>b.</b>Erstelle aus deinem eigenen Bild Versionen, die nur jeweils den Rot- , Grün- und Blauanteil zeigen. (Hinweis: Dazu müssen einfach die jeweils anderen Farbwerte auf null gesetzt werden).</p>

		
		<p class="task"><b>c.</b>Nun erzeuge jeweils ein Bild für Y, Cb und Cr. Lese dafür jedes Pixel ein und berechne die Helligkeit Y (Luminanzformel!) sowie die Chrominanzen Cb und Cr (Chrominanzformeln!) aus den RGB Werten.</p>

		
		<p class="task"><b>d.</b>Wandle zur Rekonstruktion deines Bildes die YCbCr Werte zurück in RGB.<br>

		<i>Ins Übungsprotokoll: Sourcecode, Bilder R, G, B bzw. Y, Cb und Cr, Rekonstruiertes Bild (YCbCr -> RGB)</i></p>

		<h3>Lösung:</h3>
		<h4>a.</h4>

		<h4>b.</h4>
		<h5>Sourcecode:</h5>
		<pre class="code_form"><xpm>
			private static void singleColorChannelImage(String inFilename, String channel, String outputFileName) throws IOException {
			  InputStream in = new FileInputStream(inFilename);
			  BmpImage bmpNewImage = BmpReader.read_bmp(in);
			  OutputStream out = new FileOutputStream(outputFileName);

			  for (int y = 0; y < bmpNewImage.image.getHeight(); y++) {
				 for (int x = 0; x < bmpNewImage.image.getWidth(); x++) {
					PixelColor color = null;
					int red = bmpNewImage.image.getRgbPixel(x, y).r;
					int green = bmpNewImage.image.getRgbPixel(x, y).g;
					int blue = bmpNewImage.image.getRgbPixel(x, y).b;

					switch(channel) {
					   case "red":
						  color = new PixelColor(0, 0, red);
						  break;
					   case "green":
						  color = new PixelColor(0, green, 0);
						  break;
					   case "blue":
						  color = new PixelColor(blue, 0, 0);
						  break;
					   default:
						  color = new PixelColor(blue, green, red);
						  break;
					}

					bmpNewImage.image.setRgbPixel(x, y, color);
				 }
			  }
			  try {
				 BmpWriter.write_bmp(out, bmpNewImage);
			  } finally {
				 out.close();
			  }
		   }
		</xmp></pre>
		
		<h5>Bilder der isolierten Farbkanäle</h5>
		<h6>Roter Kanal</h6>
		<img src="./pics/ue4/Details_Atom_Red-Channel.bmp" alt="Details_Atom_Red-Channel" width="380" height="250">
		<h6>Grüner Kanal</h6>
		<img src="./pics/ue4/Details_Atom_Green-Channel.bmp" alt="Details_Atom_Green-Channel" width="380" height="250">
		<h6>Blauer Kanal</h6>
		<img src="./pics/ue4/Details_Atom_Blue-Channel.bmp" alt="Details_Atom_Blue-Channel" width="380" height="250">

		<h4>c.</h4>
		<h5>Sourcecode:</h5>
		<pre class="code_form"><xpm>
			private static List&lt;List&lt;Double&gt;&gt; singleYCbCrChannelImage(String inFilename, String channel, String outputFileName) throws IOException {
			  InputStream in = new FileInputStream(inFilename);
			  BmpImage bmpNewImage = BmpReader.read_bmp(in);
			  OutputStream out = new FileOutputStream(outputFileName);
			  List&lt;List&lt;Double&gt;&gt; YCbCrValuesOfEveryPixel = new ArrayList&lt;&gt;();

			  for (int y = 0; y &lt; bmpNewImage.image.getHeight(); y++) {
				 for (int x = 0; x &lt; bmpNewImage.image.getWidth(); x++) {
					PixelColor color = null;

					int red = bmpNewImage.image.getRgbPixel(x, y).r;
					int green = bmpNewImage.image.getRgbPixel(x, y).g;
					int blue = bmpNewImage.image.getRgbPixel(x, y).b;
					List&lt;Integer&gt; rgb = new ArrayList&lt;&gt;(Arrays.asList(red, green, blue));
					List&lt;Double&gt; YCbCr = rgbToYCbCr(rgb);
					YCbCrValuesOfEveryPixel.add(YCbCr);
					int Y = (int)roundValue(YCbCr.get(0), 0);
					int Cb = (int)roundValue(YCbCr.get(1), 0);
					int Cr = (int)roundValue(YCbCr.get(2), 0);

					switch(channel) {
					   case &quot;Y&quot;:
						  color = new PixelColor(Y, 0, 0);
						  break;
					   case &quot;Cb&quot;:
						  color = new PixelColor(0, Cb, 0);
						  break;
					   case &quot;Cr&quot;:
						  color = new PixelColor(0, 0, Cr);
						  break;
					   default:
						  color = new PixelColor(Y, Cb, Cr);
						  break;
					}

					bmpNewImage.image.setRgbPixel(x, y, color);
				 }
			  }

			  try {
				 BmpWriter.write_bmp(out, bmpNewImage);
			  } finally {
				 out.close();
			  }

			  return YCbCrValuesOfEveryPixel;
		   }

		   private static List&lt;Double&gt; rgbToYCbCr(List&lt;Integer&gt; rgb) {
			  int red = rgb.get(0);
			  int green = rgb.get(1);
			  int blue = rgb.get(2);

			  double Y = ((0.299*red) + (0.587*green) + (0.114*blue)) + 0;
			  double Cb = ((-0.169*red) + (-0.331*green) + (0.5*blue)) + 128;
			  double Cr = ((0.5*red) + (-0.419*green) + (-0.081*blue)) + 128;

			  Y = roundValue(Y, 2);
			  Cb = roundValue(Cb, 2);
			  Cr = roundValue(Cr, 2);

			  return new ArrayList&lt;&gt;(Arrays.asList(Y, Cb, Cr));
		   }

		   private static double roundValue(double value, int decimals) {
			  return Math.round(value * Math.pow(10, decimals))/ Math.pow(10, decimals);
		   }
		</pre></xpm>
		<h5>Luminaz- und Chromanz-Bilder</h5>
		<h6>YCbCr</h6>
		<img src="./pics/ue4/Details_Atom_Reconstructed-From-YCbCr.bmp" alt="Details_Atom_Reconstructed-From-YCbCr" width="380" height="250">
		<h6>Y</h6>
		<img src="./pics/ue4/Details_Atom_Y-Channel.bmp" alt="Details_Atom_Y-Channel" width="380" height="250">
		<h6>Cb</h6>
		<img src="./pics/ue4/Details_Atom_Cb-Channel.bmp" alt="Details_Atom_Cb-Channel" width="380" height="250">
		<h6>Cr</h6>
		<img src="./pics/ue4/Details_Atom_Cr-Channel.bmp" alt="Details_Atom_Cr-Channel" width="380" height="250">

		<h4>d.</h4>
		<h5>Sourcecode:</h5>
		<pre class="code_form"><xpm>
		   private static void reconstructRGBImageFromYCbCr(String inFilename, List&lt;List&lt;Double&gt;&gt; YCbCr, String outputFileName) throws IOException {
		  InputStream in = new FileInputStream(inFilename);
		  BmpImage bmpNewImage = BmpReader.read_bmp(in);
		  OutputStream out = new FileOutputStream(outputFileName);
		  int pixelCounter = 0;

		  for (int y = 0; y &lt; bmpNewImage.image.getHeight(); y++) {
			 for (int x = 0; x &lt; bmpNewImage.image.getWidth(); x++) {
				PixelColor color = null;
				List&lt;Double&gt; rgb = YCbCrToRGB(YCbCr.get(pixelCounter));
				int red = (int)roundValue(rgb.get(0), 0);
				int green = (int)roundValue(rgb.get(1), 0);
				int blue = (int)roundValue(rgb.get(2), 0);

				color = new PixelColor(blue, green, red);

				bmpNewImage.image.setRgbPixel(x, y, color);
				pixelCounter++;
			 }
		  }
		  try {
			 BmpWriter.write_bmp(out, bmpNewImage);
		  } finally {
			 out.close();
		  }
	   }

	   private static List&lt;Double&gt; YCbCrToRGB(List&lt;Double&gt; YCbCr) {
		  double Y = YCbCr.get(0);
		  double Cb = YCbCr.get(1);
		  double Cr = YCbCr.get(2);

		  double red = (1*Y) + (0*(Cb-128)) + (1.403*(Cr-128));
		  double green = (1*Y) + (-0.344*(Cb-128)) + (-0.714*(Cr-128));
		  double blue = (1*Y) + (1.773*(Cb-128)) + (0*(Cr-128));

		  red = roundValue(red, 2);
		  green = roundValue(green, 2);
		  blue = roundValue(blue, 2);

		  return new ArrayList&lt;&gt;(Arrays.asList(red, green, blue));
	   }
		</pre></xpm>
		<h5>Rekonstruiertes RGB Bild aus YCbCr-Werten</h5>
		<img src="./pics/ue4/Details_Atom_Reconstructed-From-YCbCr.bmp" alt="Details_Atom_Reconstructed-From-YCbCr" width="380" height="250">
	</div>
	<br>
	<div>
		<h3>Aufgabe 2: Histogramm</h3>
		<p class="task">Mithilfe eines Histogramms kann die Verteilung (Häufigkeit) der Helligkeiten eines Bildes dargestellt werden. Erstelle ein Histogramm für das monochrome Detailbild aus Aufgabe 1 (Y - Bild). Lese dafür den Helligkeitswert der Pixel ein und bestimme die Helligkeitshäufigkeiten (Anzahl gleicher Helligkeiten). Diese sollen in eine Textdatei geschrieben und als Histogramm dargestellt werden (z.B. in Excel, Java).</p>
		<p class="task">Ins Übungsprotokoll: Sourcecode, Histogramm des Bildes</p>

		<h3>Lösung:</h3>
		<h5>Sourcecode:</h5>
		<pre class="code_form"><xpm>
			  private static void histogramm(String inFilename, String outputTextFileName, String outputImageFileName) throws IOException {
			  InputStream in = new FileInputStream(inFilename);
			  BmpImage bmpNewImage = BmpReader.read_bmp(in);
			  PrintWriter outText = new PrintWriter(outputTextFileName);
			  OutputStream outImage = new FileOutputStream(outputImageFileName);
			  List&lt;Integer&gt; histogramm = new ArrayList&lt;&gt;();

			  // Initialise Histogramm
			  for (int i = 0; i &lt; 256; i++) {
				 histogramm.add(0);
			  }

			  for (int y = 0; y &lt; bmpNewImage.image.getHeight(); y++) {
				 for (int x = 0; x &lt; bmpNewImage.image.getWidth(); x++) {
					int red = bmpNewImage.image.getRgbPixel(x, y).r;
					int green = bmpNewImage.image.getRgbPixel(x, y).g;
					int blue = bmpNewImage.image.getRgbPixel(x, y).b;

					int averageValue = (red+green+blue)/3;
					int Y = averageValue; // Helligkeitswert

					if (valueIsInInclusiveIntervall(Y, 0, 255)) {
					   histogramm.set(Y, histogramm.get(Y)+1);
					} else {
					   throw new RuntimeException(&quot;Value is out of the Intervall: [0..255]&quot;);
					}
				 }
			  }

			  try {
				 for (int value: histogramm) outText.println(value+&quot;,&quot;);
				 BmpWriter.write_bmp(outImage, bmpNewImage);
			  } finally {
				 outText.close();
				 outImage.close();
			  }
		   }

		   private static boolean valueIsInInclusiveIntervall(int value, int min, int max) {
			  return (min &lt;= value &amp;&amp; value &lt;= max);
		   }
		</pre></xpm>
		<h5>Histogramm</h5>
		<img src="./pics/ue4/Details_Atom_Y-Histogramm.png" alt="Details_Atom_Y-Histogramm" width="800">
	</div>
<br>
<h3>Aufgabe 3: Helligkeit und Kontrast</h3>	
	<p class = "task"><b>a.</b> Berechne die mittlere Helligkeit des monochromen Detailbildes aus Aufgabe 1 (Y - Bild). Lese dafür den
Helligkeitswert der Pixel ein. Die mittlere Helligkeit ist die Summe aller Helligkeitswerte geteilt durch die
Anzahl der Bildpunkte. Berechne auch den Kontrast des Bildes, d.h. die Standardabweichung der Helligkeit.<br>
</p><p class = "task"><b>b.</b>  Verändere das monochrome Bild in der Helligkeit durch Subtrahieren bzw. Addieren eines konstanten
Werts (20 +/- Schrittweite) bis zur minimalen (dunkel) und maximalen (hell) Helligkeit, d.h. so dass das
jeweilige Motiv gerade noch zu erkennen ist. Beachte dabei, dass ihr beim Ergebnis der
Pixelwertberechnung im 8-Bit-Bereich bleibt. Berechne die Histogramme des hellsten und dunkelsten
Bildes.<br></p>
<p class = "task"><b>c.</b>  Erhöhe bzw. verringere den Kontrast durch Multiplikation mit den Faktoren k=(0.2, 0.4, 0.8, 1.0) sowie
k=(1.5, 2.5, 5.0, 10.0). Ab welcher Verstärkung bleibt nur noch ein s/w Bild? Was würde bei einer
Kontraständerung mit k < 0 passieren (Einfach ausprobieren und Bild speichern!)?
Berechne auch hier das Histogramm des kontrastärmsten und kontrastreichsten Bildes und vergleiche mit
denen der Helligkeitsänderung. Was haben Helligkeits- und Kontraständerung für eine Auswirkung auf das
Histogramm (Vergleiche auch mit dem Histogramm aus Aufgabe 2)?
<br><i> Ins Übungsprotokoll: Sourcecode, Ergebnisse für mittlere Helligkeit und Kontrast, Ergebnisse
Minimum/Maximum für Helligkeit und Kontrast mit dazugehörigen Histogrammen, Alle Bilder</i>
</p>
<br>
	
<br>	
</body>

</html>
